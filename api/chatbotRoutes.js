import express from 'express';
import { db } from '../index.js';
import { verifyToken } from '../middleware/auth.js';

const router = express.Router();

router.post('/chatbot/nueva-conversacion', verifyToken, async (req, res) => {
    try {
        const userId = req.user.userId;
        if (!userId) {
            return res.status(400).json({ error: 'Usuario no identificado' });
        }
        
        const [directivo] = await db.execute(
            'SELECT id FROM directivos WHERE usuario_id = ?',
            [userId]
        );
        
        if (directivo.length === 0) {
            return res.status(403).json({ error: 'Usuario no es directivo' });
        }
        
        const directivoId = directivo[0].id;
        const [result] = await db.execute(
            `INSERT INTO conversaciones_chatbot (directivo_id, titulo) VALUES (?, ?)`,
            [directivoId, 'Nueva conversaci√≥n']
        );
        
        res.json({ 
            success: true, 
            conversacionId: result.insertId 
        });
    } catch (error) {
        console.error('Error al crear conversaci√≥n:', error);
        res.status(500).json({ error: 'Error interno del servidor' });
    }
});

router.get('/chatbot/conversaciones', verifyToken, async (req, res) => {
    try {
        const userId = req.user.userId;
        if (!userId) {
            return res.status(400).json({ error: 'Usuario no identificado' });
        }
        
        const [directivo] = await db.execute(
            'SELECT id FROM directivos WHERE usuario_id = ?',
            [userId]
        );
        
        if (directivo.length === 0) {
            return res.status(403).json({ error: 'Usuario no es directivo' });
        }
        
        const directivoId = directivo[0].id;
        const [rows] = await db.execute(
            `SELECT id, titulo, fecha_creacion, fecha_actualizacion 
             FROM conversaciones_chatbot 
             WHERE directivo_id = ? 
             ORDER BY fecha_actualizacion DESC 
             LIMIT 10`,
            [directivoId]
        );
        
        res.json(rows);
    } catch (error) {
        console.error('Error al obtener conversaciones:', error);
        res.status(500).json({ error: 'Error interno del servidor' });
    }
});

router.get('/chatbot/conversacion/:id', verifyToken, async (req, res) => {
    try {
        const conversacionId = req.params.id;
        const userId = req.user.userId;
        
        if (!userId) {
            return res.status(400).json({ error: 'Usuario no identificado' });
        }
        
        const [directivo] = await db.execute(
            'SELECT id FROM directivos WHERE usuario_id = ?',
            [userId]
        );
        
        if (directivo.length === 0) {
            return res.status(403).json({ error: 'Usuario no es directivo' });
        }
        
        const directivoId = directivo[0].id;
        const [conversacion] = await db.execute(
            `SELECT id FROM conversaciones_chatbot WHERE id = ? AND directivo_id = ?`,
            [conversacionId, directivoId]
        );
        
        if (conversacion.length === 0) {
            return res.status(404).json({ error: 'Conversaci√≥n no encontrada' });
        }
        
        const [mensajes] = await db.execute(
            `SELECT id, tipo_mensaje, contenido, timestamp 
             FROM mensajes_chatbot 
             WHERE conversacion_id = ? 
             ORDER BY timestamp ASC`,
            [conversacionId]
        );
        
        res.json({ mensajes });
    } catch (error) {
        console.error('Error al obtener mensajes:', error);
        res.status(500).json({ error: 'Error interno del servidor' });
    }
});
router.post('/chatbot/mensaje', verifyToken, async (req, res) => {
    try {
        const { conversacionId, mensaje } = req.body;
        const userId = req.user.userId;
        
        if (!userId || !conversacionId || !mensaje) {
            return res.status(400).json({ error: 'Datos requeridos faltantes' });
        }
        
        const [directivo] = await db.execute(
            'SELECT id FROM directivos WHERE usuario_id = ?',
            [userId]
        );
        
        if (directivo.length === 0) {
            return res.status(403).json({ error: 'Usuario no es directivo' });
        }
        
        const directivoId = directivo[0].id;
        const [conversacion] = await db.execute(
            `SELECT id FROM conversaciones_chatbot WHERE id = ? AND directivo_id = ?`,
            [conversacionId, directivoId]
        );
        
        if (conversacion.length === 0) {
            return res.status(404).json({ error: 'Conversaci√≥n no encontrada' });
        }
        
        await db.execute(
            `INSERT INTO mensajes_chatbot (conversacion_id, tipo_mensaje, contenido) VALUES (?, 'pregunta', ?)`,
            [conversacionId, mensaje]
        );
        const respuesta = await generateConversationalResponse(mensaje);
        console.log('Respuesta generada:', respuesta);
        
        await db.execute(
            `INSERT INTO mensajes_chatbot (conversacion_id, tipo_mensaje, contenido) VALUES (?, 'respuesta', ?)`,
            [conversacionId, respuesta]
        );
        const [mensajesCount] = await db.execute(
            `SELECT COUNT(*) as count FROM mensajes_chatbot WHERE conversacion_id = ?`,
            [conversacionId]
        );
        
        if (mensajesCount[0].count <= 2) {
            const titulo = mensaje.length > 30 ? mensaje.substring(0, 30) + '...' : mensaje;
            await db.execute(
                `UPDATE conversaciones_chatbot SET titulo = ? WHERE id = ?`,
                [titulo, conversacionId]
            );
        }
        
        await db.execute(
            `UPDATE conversaciones_chatbot SET fecha_actualizacion = NOW() WHERE id = ?`,
            [conversacionId]
        );
        
        res.json({ 
            success: true, 
            respuesta 
        });
        
    } catch (error) {
        console.error('Error al procesar mensaje:', error);
        res.status(500).json({ error: 'Error interno del servidor' });
    }
});
async function generateConversationalResponse(mensaje) {
    const mensajeLower = mensaje.toLowerCase().trim();
    
    try {
        console.log('ü§ñ Analizando mensaje:', mensaje);
        
        const analysis = analyzeMessage(mensajeLower);
        console.log('üìä An√°lisis:', analysis);
        if (analysis.subject === 'profesor' || analysis.subject === 'docente') {
            return await handleTeacherQuery(analysis, mensaje);
        }
        
        if (analysis.subject === 'estudiante' || analysis.subject === 'alumno') {
            return await handleStudentQuery(analysis, mensaje);
        }
        
        if (analysis.subject === 'grupo' || analysis.subject === 'salon') {
            return await handleGroupQuery(analysis, mensaje);
        }
        
        if (analysis.subject === 'carrera' || analysis.subject === 'programa') {
            return await handleCareerQuery(analysis, mensaje);
        }
        
        if (analysis.subject === 'directivo') {
            return await handleDirectiveQuery(analysis, mensaje);
        }
        
        if (analysis.intent === 'greeting') {
            return handleGreeting();
        }
        
        if (analysis.intent === 'help' || analysis.intent === 'capabilities') {
            return handleHelp();
        }
        
        if (analysis.intent === 'comparison') {
            return await handleComparison(analysis, mensaje);
        }
        
        if (analysis.intent === 'statistics') {
            return await handleStatistics(analysis, mensaje);
        }
        return await handleIntelligentSearch(mensaje, analysis);
        
    } catch (error) {
        console.error('‚ùå Error en generateConversationalResponse:', error);
        return `Ups, tuve un peque√±o problema procesando tu pregunta sobre "${mensaje}". üòÖ

¬øPodr√≠as reformularla? Por ejemplo:
‚Ä¢ "¬øCu√°l es el mejor profesor de matem√°ticas?"
‚Ä¢ "¬øQu√© estudiante tiene mejor promedio?"
‚Ä¢ "¬øCu√°l grupo tiene mejor rendimiento?"

Estoy aqu√≠ para ayudarte con cualquier informaci√≥n espec√≠fica que necesites. ü§ñ`;
    }
}

function analyzeMessage(mensaje) {
    const analysis = {
        subject: null,     
        action: null,      
        qualifier: null,  
        scope: null, 
        intent: null 
    };
    if (/\b(profesor|profesores|docente|docentes|maestro|maestros|tutor|tutores)\b/.test(mensaje)) {
        analysis.subject = 'profesor';
    } else if (/\b(estudiante|estudiantes|alumno|alumnos|matricula|matr√≠cula)\b/.test(mensaje)) {
        analysis.subject = 'estudiante';
    } else if (/\b(grupo|grupos|salon|sal√≥n|clase|clases)\b/.test(mensaje)) {
        analysis.subject = 'grupo';
    } else if (/\b(carrera|carreras|programa|programas|licenciatura)\b/.test(mensaje)) {
        analysis.subject = 'carrera';
    } else if (/\b(directivo|directivos|director|coordinador)\b/.test(mensaje)) {
        analysis.subject = 'directivo';
    }
    if (/\b(mejor|mejores|bueno|buenos|excelente|sobresaliente|destacado|top|primero)\b/.test(mensaje)) {
        analysis.qualifier = 'best';
    } else if (/\b(peor|peores|malo|malos|bajo|reprobado|reprobados|√∫ltimo)\b/.test(mensaje)) {
        analysis.qualifier = 'worst';
    } else if (/\b(m√°s|mayor|m√°ximo|superior)\b/.test(mensaje)) {
        analysis.qualifier = 'most';
    } else if (/\b(menos|menor|m√≠nimo|inferior)\b/.test(mensaje)) {
        analysis.qualifier = 'least';
    }
    if (/\b(comparar|versus|vs|diferencia|entre)\b/.test(mensaje)) {
        analysis.action = 'compare';
    } else if (/\b(listar|mostrar|dame|ver|todos)\b/.test(mensaje)) {
        analysis.action = 'list';
    } else if (/\b(buscar|encontrar|qui√©n|quien|cu√°l|cual)\b/.test(mensaje)) {
        analysis.action = 'find';
    }
    if (/\b(tsu|t√©cnico superior)\b/.test(mensaje)) {
        analysis.scope = 'tsu';
    } else if (/\b(ingenier√≠a|ingenieria|ing)\b/.test(mensaje)) {
        analysis.scope = 'ingenieria';
    }
    
    const cuatrimestreMatch = mensaje.match(/\b(cuatri|cuatrimestre)\s*(\d+)\b/);
    if (cuatrimestreMatch) {
        analysis.scope = `cuatrimestre_${cuatrimestreMatch[2]}`;
    }
    
    const grupoMatch = mensaje.match(/\bgrupo\s*([a-zA-Z0-9]+)\b/);
    if (grupoMatch) {
        analysis.scope = `grupo_${grupoMatch[1].toUpperCase()}`;
    }
    if (/\b(hola|hello|hey|buenas|saludos)\b/.test(mensaje)) {
        analysis.intent = 'greeting';
    } else if (/\b(ayuda|help|que puedes|qu√© puedes|capacidades)\b/.test(mensaje)) {
        analysis.intent = 'help';
    } else if (/\b(estad√≠stica|estad√≠sticas|resumen|total|cantidad)\b/.test(mensaje)) {
        analysis.intent = 'statistics';
    } else if (/\b(comparar|versus|diferencia)\b/.test(mensaje)) {
        analysis.intent = 'comparison';
    }
    
    return analysis;
}
async function handleTeacherQuery(analysis, mensaje) {
    try {
        let baseQuery = `
            SELECT 
                CONCAT(u.nombre, ' ', u.apellido) as profesor,
                p.numero_empleado,
                c.nombre as carrera,
                p.titulo_academico,
                p.especialidad,
                p.experiencia_a√±os,
                p.es_tutor,
                COUNT(DISTINCT pag.asignatura_id) as asignaturas_impartidas,
                COUNT(DISTINCT cal.id) as estudiantes_evaluados,
                AVG(cal.calificacion_final) as promedio_estudiantes,
                COUNT(DISTINCT CASE WHEN cal.estatus = 'aprobado' THEN cal.id END) as estudiantes_aprobados,
                ROUND((COUNT(DISTINCT CASE WHEN cal.estatus = 'aprobado' THEN cal.id END) * 100.0 / 
                       NULLIF(COUNT(DISTINCT cal.id), 0)), 2) as porcentaje_aprobacion
            FROM profesores p
            INNER JOIN usuarios u ON p.usuario_id = u.id
            INNER JOIN carreras c ON p.carrera_id = c.id
            LEFT JOIN profesor_asignatura_grupo pag ON p.id = pag.profesor_id AND pag.activo = TRUE
            LEFT JOIN calificaciones cal ON p.id = cal.profesor_id AND cal.calificacion_final IS NOT NULL
            WHERE p.activo = TRUE AND u.activo = TRUE
        `;
        
        let params = [];
        let whereClause = '';
        if (analysis.scope === 'tsu') {
            whereClause += ' AND c.duracion_cuatrimestres = 6';
        } else if (analysis.scope === 'ingenieria') {
            whereClause += ' AND c.duracion_cuatrimestres = 9';
        }
        
        baseQuery += whereClause + `
            GROUP BY p.id, u.nombre, u.apellido, p.numero_empleado, c.nombre, 
                     p.titulo_academico, p.especialidad, p.experiencia_a√±os, p.es_tutor
            HAVING estudiantes_evaluados > 0
        `;
        if (analysis.qualifier === 'best') {
            baseQuery += ' ORDER BY porcentaje_aprobacion DESC, promedio_estudiantes DESC, experiencia_a√±os DESC';
        } else if (analysis.qualifier === 'worst') {
            baseQuery += ' ORDER BY porcentaje_aprobacion ASC, promedio_estudiantes ASC';
        } else {
            baseQuery += ' ORDER BY experiencia_a√±os DESC, porcentaje_aprobacion DESC';
        }
        
        baseQuery += ' LIMIT 10';
        
        const [rows] = await db.execute(baseQuery, params);
        
        if (rows.length === 0) {
            return `No encontr√© profesores que coincidan con tu b√∫squeda "${mensaje}". ü§î

¬øPodr√≠as intentar con:
‚Ä¢ "¬øCu√°l es el mejor profesor de TSU?"
‚Ä¢ "Profesor con m√°s experiencia en ingenier√≠a"
‚Ä¢ "¬øQu√© docente tiene mejor rendimiento con estudiantes?"`;
        }
        
        let respuesta = '';
        
        if (analysis.qualifier === 'best') {
            respuesta = `üèÜ **Los mejores profesores seg√∫n tu consulta:**\n\n`;
        } else if (analysis.qualifier === 'worst') {
            respuesta = `üìä **Profesores que podr√≠an necesitar apoyo:**\n\n`;
        } else {
            respuesta = `üë®‚Äçüè´ **Informaci√≥n de profesores:**\n\n`;
        }
        
        if (analysis.scope === 'tsu') {
            respuesta += `üéØ **Filtrado por:** Carreras TSU\n\n`;
        } else if (analysis.scope === 'ingenieria') {
            respuesta += `üéØ **Filtrado por:** Carreras de Ingenier√≠a\n\n`;
        }
        
        rows.forEach((profesor, index) => {
            const posicion = index === 0 && analysis.qualifier === 'best' ? 'ü•á' : 
                            index === 1 && analysis.qualifier === 'best' ? 'ü•à' : 
                            index === 2 && analysis.qualifier === 'best' ? 'ü•â' : `${index + 1}.`;
            
            respuesta += `${posicion} **${profesor.profesor}**\n`;
            respuesta += `   üéì Carrera: ${profesor.carrera}\n`;
            respuesta += `   üìö Asignaturas: ${profesor.asignaturas_impartidas}\n`;
            respuesta += `   üë• Estudiantes evaluados: ${profesor.estudiantes_evaluados}\n`;
            respuesta += `   üìä Promedio estudiantes: ${parseFloat(profesor.promedio_estudiantes || 0).toFixed(2)}\n`;
            respuesta += `   ‚úÖ Tasa de aprobaci√≥n: ${profesor.porcentaje_aprobacion || 0}%\n`;
            respuesta += `   ‚è±Ô∏è Experiencia: ${profesor.experiencia_a√±os} a√±os\n`;
            if (profesor.es_tutor) {
                respuesta += `   üéØ Es tutor grupal\n`;
            }
            respuesta += `\n`;
        });
        const mejor = rows[0];
        if (analysis.qualifier === 'best') {
            respuesta += `üí° **${mejor.profesor}** destaca con una tasa de aprobaci√≥n del ${mejor.porcentaje_aprobacion}% y un promedio estudiantil de ${parseFloat(mejor.promedio_estudiantes).toFixed(2)}.`;
        }
        
        return respuesta;
        
    } catch (error) {
        console.error('Error en handleTeacherQuery:', error);
        return `Tuve un problema buscando informaci√≥n sobre profesores. ¬øPodr√≠as ser m√°s espec√≠fico?

Ejemplos:
‚Ä¢ "¬øCu√°l es el mejor profesor de matem√°ticas?"
‚Ä¢ "Profesor con m√°s experiencia"
‚Ä¢ "¬øQu√© docente tiene mejor tasa de aprobaci√≥n?"`;
    }
}
async function handleStudentQuery(analysis, mensaje) {
    try {
        let baseQuery = `
            SELECT 
                CONCAT(u.nombre, ' ', u.apellido) as estudiante,
                a.matricula,
                c.nombre as carrera,
                g.codigo as grupo,
                a.cuatrimestre_actual,
                a.promedio_general,
                COUNT(DISTINCT cal.id) as materias_evaluadas,
                SUM(CASE WHEN cal.estatus = 'aprobado' THEN 1 ELSE 0 END) as materias_aprobadas,
                SUM(CASE WHEN cal.estatus = 'reprobado' THEN 1 ELSE 0 END) as materias_reprobadas,
                AVG(cal.calificacion_final) as promedio_calificaciones
            FROM alumnos a
            INNER JOIN usuarios u ON a.usuario_id = u.id
            INNER JOIN carreras c ON a.carrera_id = c.id
            LEFT JOIN alumnos_grupos ag ON a.id = ag.alumno_id AND ag.activo = TRUE
            LEFT JOIN grupos g ON ag.grupo_id = g.id
            LEFT JOIN calificaciones cal ON a.id = cal.alumno_id AND cal.calificacion_final IS NOT NULL
            WHERE u.activo = TRUE AND a.estado_alumno = 'activo'
        `;

        
        let params = [];
        let whereClause = '';
        if (analysis.scope === 'tsu') {
            whereClause += ' AND c.duracion_cuatrimestres = 6';
        } else if (analysis.scope === 'ingenieria') {
            whereClause += ' AND c.duracion_cuatrimestres = 9';
        }
        
        if (analysis.scope && analysis.scope.startsWith('cuatrimestre_')) {
            const cuatrimestre = analysis.scope.split('_')[1];
            whereClause += ' AND a.cuatrimestre_actual = ?';
            params.push(parseInt(cuatrimestre));
        }
        
        if (analysis.scope && analysis.scope.startsWith('grupo_')) {
            const grupo = analysis.scope.split('_')[1];
            whereClause += ' AND g.codigo = ?';
            params.push(grupo);
        }
        
        baseQuery += whereClause + `
            GROUP BY a.id, u.nombre, u.apellido, a.matricula, c.nombre, g.codigo, 
                     a.cuatrimestre_actual, a.promedio_general
            HAVING materias_evaluadas > 0
        `;
        if (analysis.qualifier === 'best') {
            baseQuery += ' ORDER BY a.promedio_general DESC, promedio_calificaciones DESC';
        } else if (analysis.qualifier === 'worst') {
            baseQuery += ' ORDER BY materias_reprobadas DESC, a.promedio_general ASC';
        } else {
            baseQuery += ' ORDER BY a.promedio_general DESC';
        }
        
        baseQuery += ' LIMIT 10';
        
        const [rows] = await db.execute(baseQuery, params);
        
        if (rows.length === 0) {
            return `No encontr√© estudiantes que coincidan con "${mensaje}". ü§î

¬øPodr√≠as intentar:
‚Ä¢ "¬øCu√°l es el mejor estudiante del cuatrimestre 2?"
‚Ä¢ "Estudiante m√°s reprobado de TSU"
‚Ä¢ "¬øQui√©n tiene mejor promedio en el grupo A?"`;
        }
        
        let respuesta = '';
        
        if (analysis.qualifier === 'best') {
            respuesta = `üåü **Los estudiantes m√°s sobresalientes:**\n\n`;
        } else if (analysis.qualifier === 'worst') {
            respuesta = `üìä **Estudiantes que necesitan apoyo acad√©mico:**\n\n`;
        } else {
            respuesta = `üë• **Informaci√≥n de estudiantes:**\n\n`;
        }
        if (analysis.scope === 'tsu') respuesta += `üéØ **Filtro:** Carreras TSU\n`;
        if (analysis.scope === 'ingenieria') respuesta += `üéØ **Filtro:** Carreras de Ingenier√≠a\n`;
        if (analysis.scope && analysis.scope.startsWith('cuatrimestre_')) {
            respuesta += `üéØ **Filtro:** Cuatrimestre ${analysis.scope.split('_')[1]}\n`;
        }
        if (analysis.scope && analysis.scope.startsWith('grupo_')) {
            respuesta += `üéØ **Filtro:** Grupo ${analysis.scope.split('_')[1]}\n`;
        }
        respuesta += `\n`;
        
        rows.forEach((estudiante, index) => {
            const posicion = index === 0 && analysis.qualifier === 'best' ? 'ü•á' : 
                            index === 1 && analysis.qualifier === 'best' ? 'ü•à' : 
                            index === 2 && analysis.qualifier === 'best' ? 'ü•â' : `${index + 1}.`;
            
            respuesta += `${posicion} **${estudiante.estudiante}**\n`;
            respuesta += `   üìã Matr√≠cula: ${estudiante.matricula}\n`;
            respuesta += `   üéì Carrera: ${estudiante.carrera}\n`;
            if (estudiante.grupo) {
                respuesta += `   üë• Grupo: ${estudiante.grupo}\n`;
            }
            respuesta += `   üìà Promedio general: ${parseFloat(estudiante.promedio_general || 0).toFixed(2)}\n`;
            respuesta += `   ‚úÖ Materias aprobadas: ${estudiante.materias_aprobadas || 0}\n`;
            if (estudiante.materias_reprobadas > 0) {
                respuesta += `   ‚ùå Materias reprobadas: ${estudiante.materias_reprobadas}\n`;
            }

        });
        
        const destacado = rows[0];
        if (analysis.qualifier === 'best') {
            respuesta += `üèÜ **${destacado.estudiante}** lidera con un promedio de ${parseFloat(destacado.promedio_general).toFixed(2)}. ¬°Excelente rendimiento!`;
        } else if (analysis.qualifier === 'worst' && destacado.materias_reprobadas > 0) {
            respuesta += `üí° **${destacado.estudiante}** podr√≠a beneficiarse de tutor√≠a adicional (${destacado.materias_reprobadas} materias reprobadas).`;
        }
        
        return respuesta;
        
    } catch (error) {
        console.error('Error en handleStudentQuery:', error);
        return `Tuve un problema buscando informaci√≥n sobre estudiantes. ¬øPodr√≠as reformular tu pregunta?

Ejemplos:
‚Ä¢ "¬øCu√°l es el mejor estudiante del cuatrimestre 3?"
‚Ä¢ "Estudiante m√°s reprobado de ingenier√≠a"
‚Ä¢ "¬øQui√©n tiene mejor promedio en TSU?"`;
    }
}
async function handleGroupQuery(analysis, mensaje) {
    try {
        let baseQuery = `
            SELECT 
                g.codigo as grupo,
                c.nombre as carrera,
                g.cuatrimestre,
                COUNT(DISTINCT ag.alumno_id) as total_estudiantes,
                g.capacidad_maxima,
                ROUND((COUNT(DISTINCT ag.alumno_id) * 100.0 / g.capacidad_maxima), 2) as porcentaje_ocupacion,
                AVG(a.promedio_general) as promedio_grupo,
                COUNT(DISTINCT cal.id) as evaluaciones_totales,
                AVG(cal.calificacion_final) as promedio_calificaciones,
                COUNT(DISTINCT CASE WHEN cal.estatus = 'aprobado' THEN cal.id END) as aprobaciones,
                ROUND((COUNT(DISTINCT CASE WHEN cal.estatus = 'aprobado' THEN cal.id END) * 100.0 / 
                       NULLIF(COUNT(DISTINCT cal.id), 0)), 2) as tasa_aprobacion,
                CONCAT(u.nombre, ' ', u.apellido) as profesor_tutor
            FROM grupos g
            INNER JOIN carreras c ON g.carrera_id = c.id
            LEFT JOIN alumnos_grupos ag ON g.id = ag.grupo_id AND ag.activo = TRUE
            LEFT JOIN alumnos a ON ag.alumno_id = a.id
            LEFT JOIN calificaciones cal ON a.id = cal.alumno_id AND cal.calificacion_final IS NOT NULL
            LEFT JOIN profesores p ON g.profesor_tutor_id = p.id
            LEFT JOIN usuarios u ON p.usuario_id = u.id
            WHERE g.activo = TRUE
        `;
        
        let params = [];
        let whereClause = '';
        if (analysis.scope === 'tsu') {
            whereClause += ' AND c.duracion_cuatrimestres = 6';
        } else if (analysis.scope === 'ingenieria') {
            whereClause += ' AND c.duracion_cuatrimestres = 9';
        }
        
        if (analysis.scope && analysis.scope.startsWith('cuatrimestre_')) {
            const cuatrimestre = analysis.scope.split('_')[1];
            whereClause += ' AND g.cuatrimestre = ?';
            params.push(parseInt(cuatrimestre));
        }
        
        baseQuery += whereClause + `
            GROUP BY g.id, g.codigo, c.nombre, g.cuatrimestre, g.capacidad_maxima, u.nombre, u.apellido
            HAVING total_estudiantes > 0
        `;
        if (analysis.qualifier === 'best') {
            baseQuery += ' ORDER BY promedio_grupo DESC, tasa_aprobacion DESC';
        } else if (analysis.qualifier === 'worst') {
            baseQuery += ' ORDER BY promedio_grupo ASC, tasa_aprobacion ASC';
        } else {
            baseQuery += ' ORDER BY promedio_grupo DESC';
        }
        
        baseQuery += ' LIMIT 10';
        
        const [rows] = await db.execute(baseQuery, params);
        if (rows.length === 0) {
            return `No encontr√© grupos que coincidan con "${mensaje}". ü§î

¬øPodr√≠as intentar:
‚Ä¢ "¬øCu√°l es el mejor grupo del cuatrimestre 3?"
‚Ä¢ "Grupo con peor rendimiento en TSU"
‚Ä¢ "¬øQu√© grupo tiene mejor promedio?"`;
        }
        
        let respuesta = '';
        
        if (analysis.qualifier === 'best') {
            respuesta = `üèÜ **Los grupos con mejor rendimiento:**\n\n`;
        } else if (analysis.qualifier === 'worst') {
            respuesta = `üìä **Grupos que necesitan atenci√≥n:**\n\n`;
        } else {
            respuesta = `üë• **Informaci√≥n de grupos:**\n\n`;
        }
        if (analysis.scope === 'tsu') respuesta += `üéØ **Filtro:** Carreras TSU\n`;
        if (analysis.scope === 'ingenieria') respuesta += `üéØ **Filtro:** Carreras de Ingenier√≠a\n`;
        if (analysis.scope && analysis.scope.startsWith('cuatrimestre_')) {
            respuesta += `üéØ **Filtro:** Cuatrimestre ${analysis.scope.split('_')[1]}\n`;
        }
        respuesta += `\n`;
        
        rows.forEach((grupo, index) => {
            const posicion = index === 0 && analysis.qualifier === 'best' ? 'ü•á' : 
                            index === 1 && analysis.qualifier === 'best' ? 'ü•à' : 
                            index === 2 && analysis.qualifier === 'best' ? 'ü•â' : `${index + 1}.`;
            
            respuesta += `${posicion} **Grupo ${grupo.grupo}**\n`;
            respuesta += `   üéì Carrera: ${grupo.carrera}\n`;
            respuesta += `   üìä Cuatrimestre: ${grupo.cuatrimestre}\n`;
            respuesta += `   üë• Estudiantes: ${grupo.total_estudiantes}/${grupo.capacidad_maxima} (${grupo.porcentaje_ocupacion}%)\n`;
            respuesta += `   üìà Promedio grupal: ${parseFloat(grupo.promedio_grupo || 0).toFixed(2)}\n`;
            if (grupo.tasa_aprobacion) {
                respuesta += `   ‚úÖ Tasa de aprobaci√≥n: ${grupo.tasa_aprobacion}%\n`;
            }
            if (grupo.profesor_tutor) {
                respuesta += `   üë®‚Äçüè´ Tutor: ${grupo.profesor_tutor}\n`;
            }
            respuesta += `\n`;
        });
        const destacado = rows[0];
        if (analysis.qualifier === 'best') {
            respuesta += `üåü **El grupo ${destacado.grupo}** sobresale con un promedio de ${parseFloat(destacado.promedio_grupo).toFixed(2)}. ¬°Excelente trabajo en equipo!`;
        } else if (analysis.qualifier === 'worst') {
            respuesta += `üí° **El grupo ${destacado.grupo}** podr√≠a beneficiarse de apoyo adicional (promedio: ${parseFloat(destacado.promedio_grupo).toFixed(2)}).`;
        }
        
        return respuesta;
        
    } catch (error) {
        console.error('Error en handleGroupQuery:', error);
        return `Tuve un problema analizando los grupos. ¬øPodr√≠as ser m√°s espec√≠fico?

Ejemplos:
‚Ä¢ "¬øCu√°l es el mejor grupo de TSU?"
‚Ä¢ "Grupo con peor rendimiento del cuatrimestre 2"
‚Ä¢ "¬øQu√© grupo tiene m√°s estudiantes?"`;
    }
}
async function handleCareerQuery(analysis, mensaje) {
    try {
        const [rows] = await db.execute(`
            SELECT 
                c.nombre as carrera,
                c.codigo,
                c.duracion_cuatrimestres,
                c.descripcion,
                COUNT(DISTINCT a.id) as total_estudiantes,
                COUNT(DISTINCT p.id) as total_profesores,
                COUNT(DISTINCT asig.id) as total_asignaturas,
                AVG(a.promedio_general) as promedio_carrera,
                COUNT(DISTINCT cal.id) as evaluaciones_totales,
                SUM(CASE WHEN cal.estatus = 'aprobado' THEN 1 ELSE 0 END) as aprobaciones,
                ROUND((SUM(CASE WHEN cal.estatus = 'aprobado' THEN 1 ELSE 0 END) * 100.0 / 
                       NULLIF(COUNT(cal.id), 0)), 2) as porcentaje_aprobacion
            FROM carreras c
            LEFT JOIN alumnos a ON c.id = a.carrera_id
            LEFT JOIN usuarios u ON a.usuario_id = u.id
            LEFT JOIN profesores p ON c.id = p.carrera_id AND p.activo = TRUE
            LEFT JOIN asignaturas asig ON c.id = asig.carrera_id AND asig.activa = TRUE
            LEFT JOIN calificaciones cal ON a.id = cal.alumno_id AND cal.calificacion_final IS NOT NULL
            WHERE c.activa = TRUE AND (u.activo = TRUE OR a.id IS NULL)
            GROUP BY c.id, c.nombre, c.codigo, c.duracion_cuatrimestres, c.descripcion
            ORDER BY porcentaje_aprobacion DESC, promedio_carrera DESC
        `);
        
        if (rows.length === 0) {
            return `No encontr√© informaci√≥n sobre carreras. ü§î`;
        }
        
        let respuesta = `üéì **Informaci√≥n de carreras en DTAI:**\n\n`;
        const tsuCarreras = rows.filter(c => c.duracion_cuatrimestres === 6);
        const ingCarreras = rows.filter(c => c.duracion_cuatrimestres === 9);
        
        if (analysis.scope === 'tsu' || (!analysis.scope && tsuCarreras.length > 0)) {
            respuesta += `üìö **T√âCNICO SUPERIOR UNIVERSITARIO (TSU):**\n\n`;
            tsuCarreras.forEach((carrera, index) => {
                respuesta += `${index + 1}. **${carrera.carrera}** (${carrera.codigo})\n`;
                respuesta += `   üë• Estudiantes: ${carrera.total_estudiantes || 0}\n`;
                respuesta += `   üë®‚Äçüè´ Profesores: ${carrera.total_profesores || 0}\n`;
                respuesta += `   üìö Asignaturas: ${carrera.total_asignaturas || 0}\n`;
                respuesta += `   üìä Promedio: ${parseFloat(carrera.promedio_carrera || 0).toFixed(2)}\n`;
                if (carrera.porcentaje_aprobacion) {
                    respuesta += `   ‚úÖ Aprobaci√≥n: ${carrera.porcentaje_aprobacion}%\n`;
                }
                respuesta += `\n`;
            });
        }
        
        if (analysis.scope === 'ingenieria' || (!analysis.scope && ingCarreras.length > 0)) {
            respuesta += `üî¨ **INGENIER√çA:**\n\n`;
            ingCarreras.forEach((carrera, index) => {
                respuesta += `${index + 1}. **${carrera.carrera}** (${carrera.codigo})\n`;
                respuesta += `   üë• Estudiantes: ${carrera.total_estudiantes || 0}\n`;
                respuesta += `   üë®‚Äçüè´ Profesores: ${carrera.total_profesores || 0}\n`;
                respuesta += `   üìö Asignaturas: ${carrera.total_asignaturas || 0}\n`;
                respuesta += `   üìä Promedio: ${parseFloat(carrera.promedio_carrera || 0).toFixed(2)}\n`;
                if (carrera.porcentaje_aprobacion) {
                    respuesta += `   ‚úÖ Aprobaci√≥n: ${carrera.porcentaje_aprobacion}%\n`;
                }
                respuesta += `\n`;
            });
        }
        const mejorCarrera = rows[0];
        if (mejorCarrera.porcentaje_aprobacion) {
            respuesta += `üèÜ **${mejorCarrera.carrera}** lidera con ${mejorCarrera.porcentaje_aprobacion}% de aprobaci√≥n.`;
        }
        
        return respuesta;
        
    } catch (error) {
        console.error('Error en handleCareerQuery:', error);
        return `Tuve un problema consultando las carreras. ¬øPodr√≠as reformular tu pregunta?`;
    }
}
async function handleDirectiveQuery(analysis, mensaje) {
    try {
        const [rows] = await db.execute(`
            SELECT 
                CONCAT(u.nombre, ' ', u.apellido) as directivo,
                d.numero_empleado,
                d.cargo,
                d.nivel_acceso,
                c.nombre as carrera,
                d.fecha_nombramiento
            FROM directivos d
            INNER JOIN usuarios u ON d.usuario_id = u.id
            LEFT JOIN carreras c ON d.carrera_id = c.id
            WHERE u.activo = TRUE
            ORDER BY 
                CASE d.nivel_acceso 
                    WHEN 'director' THEN 1
                    WHEN 'subdirector' THEN 2
                    WHEN 'coordinador' THEN 3
                END,
                d.fecha_nombramiento DESC
        `);
        
        if (rows.length === 0) {
            return `No encontr√© informaci√≥n sobre directivos activos. ü§î`;
        }
        
        let respuesta = `üëî **Equipo directivo de DTAI** (${rows.length} personas):\n\n`;
        
        rows.forEach((directivo, index) => {
            const jerarquia = directivo.nivel_acceso === 'director' ? 'üéØ' : 
                             directivo.nivel_acceso === 'subdirector' ? 'üìã' : '‚öôÔ∏è';
            
            respuesta += `${index + 1}. ${jerarquia} **${directivo.directivo}**\n`;
            respuesta += `   üìÑ Cargo: ${directivo.cargo}\n`;
            respuesta += `   üè¢ Nivel: ${directivo.nivel_acceso}\n`;
            if (directivo.carrera) {
                respuesta += `   üéì Carrera: ${directivo.carrera}\n`;
            }
            respuesta += `   üìÖ Desde: ${new Date(directivo.fecha_nombramiento).getFullYear()}\n\n`;
        });
        
        respuesta += `üíº El equipo directivo est√° bien estructurado con ${rows.length} miembros activos.`;
        
        return respuesta;
        
    } catch (error) {
        console.error('Error en handleDirectiveQuery:', error);
        return `Tuve un problema consultando informaci√≥n de directivos.`;
    }
}
function handleGreeting() {
    const saludos = [
        `¬°Hola! üëã Soy tu asistente inteligente de DTAI. Puedo ayudarte con consultas muy espec√≠ficas sobre estudiantes, profesores, grupos y todo lo relacionado con la divisi√≥n.`,
        
        `¬°Hey! ü§ñ ¬øQu√© tal? Estoy aqu√≠ para responder cualquier pregunta espec√≠fica que tengas sobre DTAI. Desde "¬øcu√°l es el mejor profesor?" hasta "¬øqu√© estudiante necesita m√°s apoyo?".`,
        
        `¬°Buenas! üòä Soy como tu asistente personal para datos de DTAI. Puedo ser muy espec√≠fico y conversacional. ¬øQu√© te gustar√≠a saber?`
    ];
    
    const saludo = saludos[Math.floor(Math.random() * saludos.length)];
    
    return saludo + `\n\nüí° **Ejemplos de lo que puedo hacer:**
‚Ä¢ "¬øCu√°l es el mejor profesor de matem√°ticas?"
‚Ä¢ "Estudiante m√°s reprobado del cuatrimestre 2"
‚Ä¢ "¬øQu√© grupo de TSU tiene mejor promedio?"
‚Ä¢ "Compara el rendimiento entre carreras"
‚Ä¢ "¬øQui√©n necesita apoyo acad√©mico?"

¬°Preg√∫ntame como si fuera una conversaci√≥n normal! üöÄ`;
}
function handleHelp() {
    return `ü§ñ **¬°Soy tu asistente conversacional de DTAI!**

Puedo entender y responder preguntas naturales como si fuera una persona. No necesitas comandos espec√≠ficos.

üéØ **EJEMPLOS DE CONSULTAS ESPEC√çFICAS:**

**Sobre profesores:**
‚Ä¢ "¬øCu√°l es el mejor profesor de la carrera?"
‚Ä¢ "Profesor con m√°s experiencia en TSU"
‚Ä¢ "¬øQu√© docente tiene mejor rendimiento?"
‚Ä¢ "Profesor que necesita apoyo"

**Sobre estudiantes:**
‚Ä¢ "¬øCu√°l es el alumno m√°s reprobado del cuatrimestre 2?"
‚Ä¢ "Mejor estudiante del grupo A"
‚Ä¢ "¬øQui√©n tiene el promedio m√°s alto?"
‚Ä¢ "Estudiantes en riesgo acad√©mico"

**Sobre grupos:**
‚Ä¢ "¬øQu√© grupo tiene mejor rendimiento?"
‚Ä¢ "Grupo con m√°s problemas en TSU"
‚Ä¢ "¬øCu√°l es el mejor grupo del cuatrimestre 3?"

**Comparaciones:**
‚Ä¢ "Compara TSU vs Ingenier√≠a"
‚Ä¢ "¬øQu√© carrera tiene mejor promedio?"
‚Ä¢ "Diferencias entre grupos"

üí¨ **SOY CONVERSACIONAL:**
Habla conmigo como hablar√≠as con una persona. Entiendo contexto, sin√≥nimos y puedo ser muy espec√≠fico con los datos.

¬øQu√© informaci√≥n espec√≠fica necesitas? üöÄ`;
}
async function handleComparison(analysis, mensaje) {
    try {
        const [comparacion] = await db.execute(`
            SELECT 
                CASE 
                    WHEN c.duracion_cuatrimestres = 6 THEN 'TSU'
                    WHEN c.duracion_cuatrimestres = 9 THEN 'Ingenier√≠a'
                END as tipo_carrera,
                COUNT(DISTINCT c.id) as total_carreras,
                COUNT(DISTINCT a.id) as total_estudiantes,
                COUNT(DISTINCT p.id) as total_profesores,
                AVG(a.promedio_general) as promedio_tipo,
                COUNT(DISTINCT cal.id) as evaluaciones_totales,
                SUM(CASE WHEN cal.estatus = 'aprobado' THEN 1 ELSE 0 END) as aprobaciones,
                ROUND((SUM(CASE WHEN cal.estatus = 'aprobado' THEN 1 ELSE 0 END) * 100.0 / 
                       NULLIF(COUNT(cal.id), 0)), 2) as porcentaje_aprobacion
            FROM carreras c
            LEFT JOIN alumnos a ON c.id = a.carrera_id
            LEFT JOIN usuarios u ON a.usuario_id = u.id
            LEFT JOIN profesores p ON c.id = p.carrera_id AND p.activo = TRUE
            LEFT JOIN calificaciones cal ON a.id = cal.alumno_id AND cal.calificacion_final IS NOT NULL
            WHERE c.activa = TRUE AND (u.activo = TRUE OR a.id IS NULL)
            GROUP BY tipo_carrera
            ORDER BY promedio_tipo DESC
        `);
        
        if (comparacion.length === 0) {
            return `No encontr√© datos suficientes para hacer comparaciones. ü§î`;
        }
        
        let respuesta = `üìä **Comparaci√≥n TSU vs Ingenier√≠a en DTAI:**\n\n`;
        
        comparacion.forEach((tipo, index) => {
            const emoji = tipo.tipo_carrera === 'TSU' ? 'üìö' : 'üî¨';
            const posicion = index === 0 ? 'ü•á' : 'ü•à';
            
            respuesta += `${posicion} ${emoji} **${tipo.tipo_carrera}**\n`;
            respuesta += `   üéì Carreras: ${tipo.total_carreras}\n`;
            respuesta += `   üë• Estudiantes: ${tipo.total_estudiantes}\n`;
            respuesta += `   üë®‚Äçüè´ Profesores: ${tipo.total_profesores}\n`;
            respuesta += `   üìä Promedio: ${parseFloat(tipo.promedio_tipo || 0).toFixed(2)}\n`;
            if (tipo.porcentaje_aprobacion) {
                respuesta += `   ‚úÖ Aprobaci√≥n: ${tipo.porcentaje_aprobacion}%\n`;
            }
            respuesta += `\n`;
        });
        if (comparacion.length >= 2) {
            const mejor = comparacion[0];
            const diferencia = parseFloat(comparacion[0].promedio_tipo) - parseFloat(comparacion[1].promedio_tipo);
            
            respuesta += `üéØ **An√°lisis:** ${mejor.tipo_carrera} lidera con un promedio ${diferencia.toFixed(2)} puntos superior. `;
            
            if (mejor.porcentaje_aprobacion > comparacion[1].porcentaje_aprobacion) {
                respuesta += `Tambi√©n tiene mejor tasa de aprobaci√≥n.`;
            }
        }
        
        return respuesta;
        
    } catch (error) {
        console.error('Error en handleComparison:', error);
        return `Tuve un problema haciendo la comparaci√≥n. ¬øPodr√≠as ser m√°s espec√≠fico sobre qu√© quieres comparar?`;
    }
}
async function handleStatistics(analysis, mensaje) {
    try {
        const [estudiantes] = await db.execute(`
            SELECT 
                COUNT(*) as total,
                SUM(CASE WHEN a.estado_alumno = 'activo' THEN 1 ELSE 0 END) as activos,
                SUM(CASE WHEN a.estado_alumno = 'egresado' THEN 1 ELSE 0 END) as egresados,
                AVG(a.promedio_general) as promedio_general
            FROM alumnos a
            INNER JOIN usuarios u ON a.usuario_id = u.id
            WHERE u.activo = TRUE
        `);
        
        const [profesores] = await db.execute(`
            SELECT 
                COUNT(*) as total,
                SUM(CASE WHEN p.es_tutor THEN 1 ELSE 0 END) as tutores
            FROM profesores p
            INNER JOIN usuarios u ON p.usuario_id = u.id
            WHERE p.activo = TRUE AND u.activo = TRUE
        `);
        
        const [carreras] = await db.execute(`
            SELECT COUNT(*) as total FROM carreras WHERE activa = TRUE
        `);
        
        const est = estudiantes[0];
        const prof = profesores[0];
        const carr = carreras[0];
        
        return `üìä **Estad√≠sticas generales de DTAI:**

üéì **Estudiantes:**
   ‚Ä¢ Total: ${est.total}
   ‚Ä¢ Activos: ${est.activos}
   ‚Ä¢ Egresados: ${est.egresados}
   ‚Ä¢ Promedio general: ${parseFloat(est.promedio_general || 0).toFixed(2)}

üë®‚Äçüè´ **Profesores:**
   ‚Ä¢ Total activos: ${prof.total}
   ‚Ä¢ Tutores: ${prof.tutores}

üè´ **Carreras activas:** ${carr.total}

üí° La divisi√≥n mantiene un crecimiento estable con ${est.activos} estudiantes activos y ${prof.total} profesores comprometidos con la excelencia acad√©mica.

¬øTe interesa alg√∫n dato m√°s espec√≠fico?`;
        
    } catch (error) {
        console.error('Error en handleStatistics:', error);
        return `Tuve un problema obteniendo las estad√≠sticas. ¬øPodr√≠as preguntar algo m√°s espec√≠fico?`;
    }
}
async function handleIntelligentSearch(mensaje, analysis) {
    try {
        const palabrasClave = mensaje.toLowerCase().split(' ').filter(word => word.length > 2);
        let resultados = [];
        for (const palabra of palabrasClave.slice(0, 3)) { 
            const [estudiantes] = await db.execute(`
                SELECT 
                    CONCAT(u.nombre, ' ', u.apellido) as nombre,
                    a.matricula,
                    c.nombre as carrera,
                    a.promedio_general,
                    'estudiante' as tipo
                FROM alumnos a
                INNER JOIN usuarios u ON a.usuario_id = u.id
                INNER JOIN carreras c ON a.carrera_id = c.id
                WHERE (LOWER(u.nombre) LIKE ? OR LOWER(u.apellido) LIKE ? OR a.matricula LIKE ?)
                AND u.activo = TRUE
                LIMIT 2
            `, [`%${palabra}%`, `%${palabra}%`, `%${palabra}%`]);
            
            if (estudiantes.length > 0) {
                resultados = [...resultados, ...estudiantes];
            }
        }
        
        if (resultados.length > 0) {
            let respuesta = `üîç **Encontr√© informaci√≥n relacionada con "${mensaje}":**\n\n`;
            
            resultados.slice(0, 5).forEach((resultado, index) => {
                respuesta += `${index + 1}. üë§ **${resultado.nombre}**\n`;
                respuesta += `   üìã Matr√≠cula: ${resultado.matricula}\n`;
                respuesta += `   üéì Carrera: ${resultado.carrera}\n`;
                respuesta += `   üìä Promedio: ${parseFloat(resultado.promedio_general || 0).toFixed(2)}\n\n`;
            });
            
            respuesta += `üí° ¬øNecesitas informaci√≥n m√°s espec√≠fica sobre alguno de estos estudiantes?`;
            return respuesta;
        }
        return `ü§î No encontr√© informaci√≥n espec√≠fica sobre "${mensaje}".

Pero puedo ayudarte con consultas como:

üéØ **Consultas espec√≠ficas:**
‚Ä¢ "¬øCu√°l es el mejor profesor de [materia]?"
‚Ä¢ "Estudiante m√°s reprobado del cuatrimestre [n√∫mero]"
‚Ä¢ "¬øQu√© grupo tiene mejor promedio en TSU?"
‚Ä¢ "Compara el rendimiento entre carreras"

üîç **O b√∫squedas por nombre:**
‚Ä¢ Menciona nombres de estudiantes, profesores o grupos
‚Ä¢ Pregunta sobre carreras espec√≠ficas
‚Ä¢ Solicita an√°lisis de rendimiento

¬øPodr√≠as ser m√°s espec√≠fico? Estoy aqu√≠ para ayudarte con datos muy detallados. üòä`;
        
    } catch (error) {
        console.error('Error en handleIntelligentSearch:', error);
        return `Interesante pregunta sobre "${mensaje}". ü§î

Aunque no pude procesarla completamente, puedo ayudarte con informaci√≥n muy espec√≠fica sobre:

üìä **Profesores:** rendimiento, experiencia, materias
üë• **Estudiantes:** promedios, rankings, grupos
üè´ **Grupos:** comparaciones, rendimiento
üéì **Carreras:** estad√≠sticas, comparaciones

¬øPodr√≠as reformular tu pregunta de manera m√°s directa? Por ejemplo:
‚Ä¢ "¬øCu√°l es el mejor [algo] de [contexto]?"
‚Ä¢ "¬øQui√©n tiene m√°s/menos [caracter√≠stica]?"

¬°Estoy aqu√≠ para ayudarte! üöÄ`;
    }
}

export default router;